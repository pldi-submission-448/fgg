// Code generated by go2go; DO NOT EDIT.


//line main.go2:1
package main

//line main.go2:1
import "fmt"

//line main.go2:7
const TEST_SIZE = 3000000

type Any interface{}

//line main.go2:69
func arrayInsert_int8() instantiate୦୦ResizableArray୦int8 {
	a := instantiate୦୦NewResizableArray୦int8()
	for i := 0; i < TEST_SIZE; i++ {
		a.add(int8(4))
	}
	return a
}

func arrayInsert_int32() instantiate୦୦ResizableArray୦int32 {
	a := instantiate୦୦NewResizableArray୦int32()
	for i := 0; i < TEST_SIZE; i++ {
		a.add(int32(4))
	}
	return a
}

func arrayInsert_int64() instantiate୦୦ResizableArray୦int64 {
	a := instantiate୦୦NewResizableArray୦int64()
	for i := 0; i < TEST_SIZE; i++ {
		a.add(int64(4))
	}
	return a
}

//line main.go2:99
func arrayFind_int8(a instantiate୦୦ResizableArray୦int8,) bool {
	i := 0
	b := true
	for i < TEST_SIZE {
		b = b != a.contains(int8(i))
		i += 10000
	}
	return b
}

func arrayFind_int32(a instantiate୦୦ResizableArray୦int32,) bool {
	i := 0
	b := true
	for i < TEST_SIZE {
		b = b != a.contains(int32(i))
		i += 10000
	}
	return b
}

func arrayFind_int64(a instantiate୦୦ResizableArray୦int64,) bool {
	i := 0
	b := true
	for i < TEST_SIZE {
		b = b != a.contains(int64(i))
		i += 10000
	}
	return b
}

func main_int8() {
	fmt.Println(1)
	a := arrayInsert_int8()

	fmt.Println(2)
	a = instantiate୦୦arrayReverse୦int8(a)

	fmt.Println(3)

	arrayFind_int8(a)
	fmt.Println(4)
}

func main_int32() {
	fmt.Println(1)
	a := arrayInsert_int32()

	fmt.Println(2)
	a = instantiate୦୦arrayReverse୦int32(a)

	fmt.Println(3)

	arrayFind_int32(a)
	fmt.Println(4)
}

func main_int64() {
	fmt.Println(1)
	a := arrayInsert_int64()

	fmt.Println(2)
	a = instantiate୦୦arrayReverse୦int64(a)

	fmt.Println(3)

	arrayFind_int64(a)
	fmt.Println(4)
}

func main() {
	main_int8()
	main_int32()
	main_int64()
}

//line main.go2:172
type instantiate୦୦ResizableArray୦int8 struct {
//line main.go2:12
 size      int
			elemCount int
			array     []int8
			newArray  []int8
}

//line main.go2:27
func (ra *instantiate୦୦ResizableArray୦int8,) extend() {
	if ra.elemCount == ra.size {
		pos := 0
		ra.newArray = make([]int8, 2*ra.size)
		for pos < ra.size {
			ra.newArray[pos] = ra.array[pos]
			pos += 1
		}
		ra.array = ra.newArray
		ra.size *= 2
	}
}

func (ra *instantiate୦୦ResizableArray୦int8,) add(elem int8) {
	ra.extend()
	ra.array[ra.elemCount] = elem
	ra.elemCount += 1
}

func (ra *instantiate୦୦ResizableArray୦int8,) reverse() {
	pos := 0
	for pos*2 < ra.elemCount {
		tmp1 := ra.array[pos]
		tmp2 := ra.array[ra.elemCount-pos-1]
		ra.array[pos] = tmp2
		ra.array[ra.elemCount-pos-1] = tmp1
		pos += 1
	}
}

func (ra *instantiate୦୦ResizableArray୦int8,) contains(elem int8) bool {
	pos := 0
	for pos < ra.elemCount {
		if ra.array[pos] == elem {
			return true
		}
		pos += 1
	}
	return false
}
//line main.go2:18
func instantiate୦୦NewResizableArray୦int8() instantiate୦୦ResizableArray୦int8 {
	return instantiate୦୦ResizableArray୦int8{
		size:      4,
		elemCount: 0,
		array:     make([]int8, 4),
		newArray:  nil,
	}
}

//line main.go2:25
type instantiate୦୦ResizableArray୦int32 struct {
//line main.go2:12
 size      int
			elemCount int
			array     []int32
			newArray  []int32
}

//line main.go2:27
func (ra *instantiate୦୦ResizableArray୦int32,) extend() {
	if ra.elemCount == ra.size {
		pos := 0
		ra.newArray = make([]int32, 2*ra.size)
		for pos < ra.size {
			ra.newArray[pos] = ra.array[pos]
			pos += 1
		}
		ra.array = ra.newArray
		ra.size *= 2
	}
}

func (ra *instantiate୦୦ResizableArray୦int32,) add(elem int32) {
	ra.extend()
	ra.array[ra.elemCount] = elem
	ra.elemCount += 1
}

func (ra *instantiate୦୦ResizableArray୦int32,) reverse() {
	pos := 0
	for pos*2 < ra.elemCount {
		tmp1 := ra.array[pos]
		tmp2 := ra.array[ra.elemCount-pos-1]
		ra.array[pos] = tmp2
		ra.array[ra.elemCount-pos-1] = tmp1
		pos += 1
	}
}

func (ra *instantiate୦୦ResizableArray୦int32,) contains(elem int32) bool {
	pos := 0
	for pos < ra.elemCount {
		if ra.array[pos] == elem {
			return true
		}
		pos += 1
	}
	return false
}
//line main.go2:18
func instantiate୦୦NewResizableArray୦int32() instantiate୦୦ResizableArray୦int32 {
	return instantiate୦୦ResizableArray୦int32{
		size:      4,
		elemCount: 0,
		array:     make([]int32, 4),
		newArray:  nil,
	}
}

//line main.go2:25
type instantiate୦୦ResizableArray୦int64 struct {
//line main.go2:12
 size      int
			elemCount int
			array     []int64
			newArray  []int64
}

//line main.go2:27
func (ra *instantiate୦୦ResizableArray୦int64,) extend() {
	if ra.elemCount == ra.size {
		pos := 0
		ra.newArray = make([]int64, 2*ra.size)
		for pos < ra.size {
			ra.newArray[pos] = ra.array[pos]
			pos += 1
		}
		ra.array = ra.newArray
		ra.size *= 2
	}
}

func (ra *instantiate୦୦ResizableArray୦int64,) add(elem int64) {
	ra.extend()
	ra.array[ra.elemCount] = elem
	ra.elemCount += 1
}

func (ra *instantiate୦୦ResizableArray୦int64,) reverse() {
	pos := 0
	for pos*2 < ra.elemCount {
		tmp1 := ra.array[pos]
		tmp2 := ra.array[ra.elemCount-pos-1]
		ra.array[pos] = tmp2
		ra.array[ra.elemCount-pos-1] = tmp1
		pos += 1
	}
}

func (ra *instantiate୦୦ResizableArray୦int64,) contains(elem int64) bool {
	pos := 0
	for pos < ra.elemCount {
		if ra.array[pos] == elem {
			return true
		}
		pos += 1
	}
	return false
}
//line main.go2:18
func instantiate୦୦NewResizableArray୦int64() instantiate୦୦ResizableArray୦int64 {
	return instantiate୦୦ResizableArray୦int64{
		size:      4,
		elemCount: 0,
		array:     make([]int64, 4),
		newArray:  nil,
	}
}

//line main.go2:93
func instantiate୦୦arrayReverse୦int8(a instantiate୦୦ResizableArray୦int8,) instantiate୦୦ResizableArray୦int8 {
	a.reverse()
	return a
}
//line main.go2:93
func instantiate୦୦arrayReverse୦int32(a instantiate୦୦ResizableArray୦int32,) instantiate୦୦ResizableArray୦int32 {
	a.reverse()
	return a
}
//line main.go2:93
func instantiate୦୦arrayReverse୦int64(a instantiate୦୦ResizableArray୦int64,) instantiate୦୦ResizableArray୦int64 {
	a.reverse()
	return a
}

//line main.go2:96
type Importable୦ int

//line main.go2:96
var _ = fmt.Errorf
